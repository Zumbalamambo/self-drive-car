import globimport timeimport cv2 as cvimport matplotlib.image as mpimgimport matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfrom sklearn.metrics import accuracy_scorefrom sklearn.model_selection import train_test_split, GridSearchCVfrom sklearn.preprocessing import StandardScalerfrom sklearn.svm import SVCfrom sklearn.utils import shuffledef draw_boxes(color=(0, 0, 0), thick=6):    input_img = cv.imread("/Users/siddiqui/Downloads/bbox-example-image.jpg")    bounding_boxes = [((100, 100), (200, 200)), ((300, 300), (400, 400))]    img_pts_drawn = np.copy(input_img)    for box in bounding_boxes:        cv.rectangle(img_pts_drawn, box[0], box[1], color, thick)    cv.imshow("result", img_pts_drawn)    cv.waitKey()def template_matching():    input_img, template_imgs = cv.imread(        "/Users/siddiqui/Downloads/advanced-lane-detection-images/cutouts/bbox-example-image.jpg"    ), []    img_pts_drawn = np.copy(input_img)    templates = glob.glob("/Users/siddiqui/Downloads/advanced-lane-detection-images/cutouts/cutout*.jpg")    bbox_list = []    method = cv.TM_CCOEFF    for filename in templates:        template_imgs.append(cv.imread(filename))    for template_img in template_imgs:        res = cv.matchTemplate(input_img, template_img, method)        min_val, max_val, min_loc, max_loc = cv.minMaxLoc(res)        width, height = template_img.shape[1], template_img.shape[0]        if method in [cv.TM_SQDIFF, cv.TM_SQDIFF_NORMED]:            top_left = min_loc        else:            top_left = max_loc        bottom_right = (top_left[0] + width, top_left[1] + height)        bbox_list.append((top_left, bottom_right))    print("found locs: ", bbox_list)    for box in bbox_list:        cv.rectangle(img_pts_drawn, box[0], box[1], color=(0, 0, 255), thickness=6)    cv.imshow("result", img_pts_drawn)    cv.waitKey()def color_histogram():    img = mpimg.imread(        "/Users/siddiqui/Downloads/advanced-lane-detection-images/cutouts/cutout1.jpg"    )    # r_hist[0] -> counts in each bin    # r_hist[1] -> bin edges, 1 element longer than r_hist[0]    r_hist = np.histogram(img[:, :, 0], bins=32, range=(0, 256))    g_hist = np.histogram(img[:, :, 1], bins=32, range=(0, 256))    b_hist = np.histogram(img[:, :, 2], bins=32, range=(0, 256))    hist_features = np.concatenate((r_hist[0], g_hist[0], b_hist[0]))    bin_edges = r_hist[1]    bin_centers = (bin_edges[1:] + bin_edges[0:len(bin_edges) - 1]) / 2    # Plot a figure with all three bar charts    fig = plt.figure(figsize=(12, 3))    plt.subplot(131)    plt.bar(bin_centers, r_hist[0])    plt.xlim(0, 256)    plt.title('R Histogram')    plt.subplot(132)    plt.bar(bin_centers, g_hist[0])    plt.xlim(0, 256)    plt.title('G Histogram')    plt.subplot(133)    plt.bar(bin_centers, b_hist[0])    plt.xlim(0, 256)    plt.title('B Histogram')    plt.show()def plot3d(pixels, colors_rgb,           axis_labels=list("RGB"),           axis_limits=[(0, 255), (0, 255), (0, 255)]):    """Plot pixels in 3D."""    # Create figure and 3D axes    fig = plt.figure(figsize=(8, 8))    ax = Axes3D(fig)    # Set axis limits    ax.set_xlim(*axis_limits[0])    ax.set_ylim(*axis_limits[1])    ax.set_zlim(*axis_limits[2])    # Set axis labels and sizes    ax.tick_params(axis='both', which='major', labelsize=14, pad=8)    ax.set_xlabel(axis_labels[0], fontsize=16, labelpad=16)    ax.set_ylabel(axis_labels[1], fontsize=16, labelpad=16)    ax.set_zlabel(axis_labels[2], fontsize=16, labelpad=16)    # Plot pixel values with colors given in colors_rgb    ax.scatter(        pixels[:, :, 0].ravel(),        pixels[:, :, 1].ravel(),        pixels[:, :, 2].ravel(),        c=colors_rgb.reshape((-1, 3)), edgecolors='none')    return ax  # return Axes3D object for further manipulationdef get_plot3d():    # Read a color image    img = cv.imread("/Users/siddiqui/Downloads/advanced-lane-detection-images/31.png")    # Select a small fraction of pixels to plot by subsampling it    scale = max(img.shape[0], img.shape[1], 64) / 64  # at most 64 rows and columns    img_small = cv.resize(img, (np.int(img.shape[1] / scale), np.int(img.shape[0] / scale)),                          interpolation=cv.INTER_NEAREST)    # Convert subsampled image to desired color space(s)    img_small_RGB = cv.cvtColor(img_small, cv.COLOR_BGR2RGB)  # OpenCV uses BGR, matplotlib likes RGB    img_small_HSV = cv.cvtColor(img_small, cv.COLOR_BGR2HSV)    img_small_rgb = img_small_RGB / 255.  # scaled to [0, 1], only for plotting    # Plot and show    plot3d(img_small_RGB, img_small_rgb)    plt.show()    plot3d(img_small_HSV, img_small_rgb, axis_labels=list("HSV"))    plt.show()# Define a function to compute binned color featuresdef bin_spatial(img, size=(32, 32)):    # Use cv2.resize().ravel() to create the feature vector    features = cv.resize(img, size).ravel()    # Return the feature vector    return featuresdef color_hist(img, nbins=32, bins_range=(0, 256)):    # Compute the histogram of the color channels separately    channel1_hist = np.histogram(img[:, :, 0], bins=nbins, range=bins_range)    channel2_hist = np.histogram(img[:, :, 1], bins=nbins, range=bins_range)    channel3_hist = np.histogram(img[:, :, 2], bins=nbins, range=bins_range)    # Concatenate the histograms into a single feature vector    hist_features = np.concatenate((channel1_hist[0], channel2_hist[0], channel3_hist[0]))    # Return the individual histograms, bin_centers and feature vector    return hist_featuresdef extract_features(imgs,                     spatial_size=(32, 32),                     hist_bins=32,                     cspace='RGB',                     hist_range=(0, 256)):    # Create a list to append feature vectors to    features = []    # Iterate through the list of images    for img_file in imgs:        # Read in each one by one        img = mpimg.imread(img_file)        # apply color conversion if other than 'RGB'        img = cv.COLOR_XYZ2RGB(img) if cspace is not 'RGB' else img        # Apply bin_spatial() to get spatial color features        img_bin = bin_spatial(img)        # Apply color_hist() to get color histogram features        img_hist = color_hist(img)        # Append the new feature vector to the features list        bin_hist = np.concatenate((img_bin, img_hist), axis=0)        features.append(bin_hist)    # Return list of feature vectors    return featuresdef define_classifier(spatial_size, hist_bins):    imgs_cars = glob.glob("/Users/siddiqui/Downloads/data-set/**/**/*.jpeg")    cars_files = []    not_cars_files = []    for img_file in imgs_cars:        if 'image' in img_file or 'extra' in img_file:            not_cars_files.append(img_file)        else:            cars_files.append(img_file)    # features    car_features = extract_features(cars_files, spatial_size, hist_bins)    not_cars_features = extract_features(not_cars_files, spatial_size, hist_bins)    # normalized features    features = np.vstack((car_features, not_cars_features)).astype(np.float64)    scaler = StandardScaler().fit(features)    scaled_features = scaler.transform(features)    # labels    labels = np.hstack((np.ones(len(cars_files)),                        np.zeros(len(not_cars_files))))    # split dataset    scaled_features, labels = shuffle(scaled_features, labels)    x_train, x_test, y_train, y_tests = train_test_split(scaled_features,                                                         labels,                                                         test_size=0.2,                                                         random_state=42)    params = {'kernel': ('linear', 'rbf'), 'C': [1, 10]}    svr = SVC()    clf = GridSearchCV(svr, params)    t_train_start = time.time()    clf.fit(x_train, y_train)    t_train_end = time.time()    print("best params: {}".format(clf.best_params_))    y_predict = clf.predict(x_test)    score = accuracy_score(y_tests, y_predict)    print("train time: {:.2f}s".format(t_train_end - t_train_start))    print("score: {:.3f}%".format(score * 100))h_bins, spatial = 9, 9define_classifier(spatial, h_bins)