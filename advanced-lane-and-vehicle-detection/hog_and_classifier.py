import globimport timeimport cv2 as cvimport matplotlib.image as mpimgimport matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dfrom skimage.feature import hogfrom sklearn.metrics import accuracy_scorefrom sklearn.model_selection import train_test_split, GridSearchCVfrom sklearn.preprocessing import StandardScalerfrom sklearn.svm import SVCfrom sklearn.utils import shuffledef draw_boxes(color=(0, 0, 0), thick=6):    input_img = cv.imread("/Users/siddiqui/Downloads/advanced-lane-detection-data/bbox-example-image.jpg")    bounding_boxes = [((100, 100), (200, 200)), ((300, 300), (400, 400))]    img_pts_drawn = np.copy(input_img)    for box in bounding_boxes:        cv.rectangle(img_pts_drawn, box[0], box[1], color, thick)    cv.imshow("result", img_pts_drawn)    cv.waitKey()def template_matching():    """    1- match template in given image    2- find min and max location    3- find top left and bottom right coordinates for bounding box    """    input_img = cv.imread(        "/Users/siddiqui/Downloads/advanced-lane-detection-data/cutouts/bbox-example-image.jpg"    )    img_pts_drawn = np.copy(input_img)    templates = glob.glob("/Users/siddiqui/Downloads/advanced-lane-detection-data/cutouts/cutout*.jpg")    bbox_list = []    method = cv.TM_CCOEFF    template_imgs = [cv.imread(filename) for filename in templates]    for template_img in template_imgs:        # match the templates        res = cv.matchTemplate(input_img, template_img, method)        # get the locations        min_val, max_val, min_loc, max_loc = cv.minMaxLoc(res)        # template dimension        width, height = template_img.shape[1], template_img.shape[0]        # find top left and bottom right coordinates        top_left = min_loc if method in [cv.TM_SQDIFF, cv.TM_SQDIFF_NORMED] else max_loc        bottom_right = (top_left[0] + width, top_left[1] + height)        # save in list        bbox_list.append((top_left, bottom_right))    # visualize the bounding boxes    print("found locations: ", bbox_list)    for box in bbox_list:        top_left, bottom_right = box[0], box[1]        cv.rectangle(img_pts_drawn, top_left, bottom_right, color=(0, 0, 255), thickness=6)    cv.imshow("result", img_pts_drawn)    cv.waitKey()def plot3d(pixels, colors_rgb,           axis_labels=list("RGB"),           axis_limits=[(0, 255), (0, 255), (0, 255)]):    """Plot pixels in 3D."""    # Create figure and 3D axes    fig = plt.figure(figsize=(8, 8))    ax = Axes3D(fig)    # Set axis limits    ax.set_xlim(*axis_limits[0])    ax.set_ylim(*axis_limits[1])    ax.set_zlim(*axis_limits[2])    # Set axis labels and sizes    ax.tick_params(axis='both', which='major', labelsize=14, pad=8)    ax.set_xlabel(axis_labels[0], fontsize=16, labelpad=16)    ax.set_ylabel(axis_labels[1], fontsize=16, labelpad=16)    ax.set_zlabel(axis_labels[2], fontsize=16, labelpad=16)    # Plot pixel values with colors given in colors_rgb    ax.scatter(        pixels[:, :, 0].ravel(),        pixels[:, :, 1].ravel(),        pixels[:, :, 2].ravel(),        c=colors_rgb.reshape((-1, 3)), edgecolors='none')    return ax  # return Axes3D object for further manipulationdef get_plot3d():    # Read a color image    img = cv.imread("/Users/siddiqui/Downloads/advanced-lane-detection-images/31.png")    # Select a small fraction of pixels to plot by subsampling it    scale = max(img.shape[0], img.shape[1], 64) / 64  # at most 64 rows and columns    img_small = cv.resize(img, (np.int(img.shape[1] / scale), np.int(img.shape[0] / scale)),                          interpolation=cv.INTER_NEAREST)    # Convert subsampled image to desired color space(s)    img_small_RGB = cv.cvtColor(img_small, cv.COLOR_BGR2RGB)  # OpenCV uses BGR, matplotlib likes RGB    img_small_HSV = cv.cvtColor(img_small, cv.COLOR_BGR2HSV)    img_small_rgb = img_small_RGB / 255.  # scaled to [0, 1], only for plotting    # Plot and show    plot3d(img_small_RGB, img_small_rgb)    plt.show()    plot3d(img_small_HSV, img_small_rgb, axis_labels=list("HSV"))    plt.show()# Define a function to compute binned color featuresdef bin_spatial(img=mpimg.imread("/Users/siddiqui/Downloads/advanced-lane-detection-data/cutouts/cutout1.jpg"),                size=(32, 32)):    """    1- downsize the image    2- get feature vector using ravel    """    spatial_bin_features = cv.resize(img, size).ravel()    # Return the feature vector    return spatial_bin_featuresdef color_hist(img=mpimg.imread("/Users/siddiqui/Downloads/advanced-lane-detection-data/cutouts/cutout1.jpg"),               nbins=32,               bins_range=(0, 256),               with_visualization=False):    """    finding histogram of colors    1- use np.histogram to find histogram of r, g and b channels    2- concatenate all 3 histograms --> histogram features    3- find bin centers    """    # Compute the histogram of the color channels separately    r, g, b = img[:, :, 0], img[:, :, 1], img[:, :, 2]    r_hist = np.histogram(r, bins=32, range=(0, 256))    g_hist = np.histogram(g, bins=32, range=(0, 256))    b_hist = np.histogram(b, bins=32, range=(0, 256))    hist_features = np.concatenate((r_hist[0], g_hist[0], b_hist[0]))    bin_edges = r_hist[1]    bin_centers = (bin_edges[1:] + bin_edges[0:len(bin_edges) - 1]) / 2    if with_visualization:        # Plot a figure with all three bar charts        plt.figure(figsize=(12, 4))        plt.subplot(131)        plt.bar(bin_centers, r_hist[0])        plt.xlim(0, 256)        plt.title('R Histogram')        plt.subplot(132)        plt.bar(bin_centers, g_hist[0])        plt.xlim(0, 256)        plt.title('G Histogram')        plt.subplot(133)        plt.bar(bin_centers, b_hist[0])        plt.xlim(0, 256)        plt.title('B Histogram')        cv.imshow("image", cv.cvtColor(img, cv.COLOR_RGB2BGR))        plt.show()    # Return the individual histograms, bin_centers and feature vector    return hist_features# Define a function to return HOG features and visualizationdef get_hog_features(img, orient, pix_per_cell, cell_per_block,                     vis=False, feature_vec=True):    """    finding histogram of gradient    """    # Call with two outputs if vis==True    if vis is True:        hist_features, hog_image = hog(img, orientations=orient,                                       pixels_per_cell=(pix_per_cell, pix_per_cell),                                       cells_per_block=(cell_per_block, cell_per_block),                                       transform_sqrt=True,                                       visualise=vis,                                       feature_vector=feature_vec)        return hist_features, hog_image    # Otherwise call with one output    else:        hist_features = hog(img, orientations=orient, pixels_per_cell=(pix_per_cell, pix_per_cell),                            cells_per_block=(cell_per_block, cell_per_block), transform_sqrt=True,                            visualise=vis, feature_vector=feature_vec)        return hist_featuresdef change_cspace(img, cspace):    feature_image = []    if cspace != 'RGB':        if cspace == 'HSV':            feature_image = cv.cvtColor(img, cv.COLOR_RGB2HSV)        elif cspace == 'LUV':            feature_image = cv.cvtColor(img, cv.COLOR_RGB2LUV)        elif cspace == 'HLS':            feature_image = cv.cvtColor(img, cv.COLOR_RGB2HLS)        elif cspace == 'YUV':            feature_image = cv.cvtColor(img, cv.COLOR_RGB2YUV)        elif cspace == 'YCrCb':            feature_image = cv.cvtColor(img, cv.COLOR_RGB2YCrCb)    else:        feature_image = np.copy(img)    return feature_imagedef extract_features(imgs,                     spatial_size=(32, 32),                     hist_bins=32,                     cspace='RGB',                     hist_range=(0, 256),                     orient=9,                     pix_per_cell=8, cell_per_block=2, hog_channel=0                     ):    """    combine spatial bin, color histogram and gradient histogram features    """    # Create a list to append feature vectors to    features = []    # Iterate through the list of images    for img_file in imgs:        # Read in each one by one        img = mpimg.imread(img_file)        # apply color conversion if other than 'RGB'        feature_image = change_cspace(img, cspace)        # get hog features for either specific channel or for all channels        if hog_channel == 'ALL':            hog_features = []            # get features for all 3 channels            for channel in range(feature_image.shape[2]):                hog_features.append(get_hog_features(feature_image[:, :, channel],                                                     orient, pix_per_cell, cell_per_block,                                                     feature_vec=True, vis=False))            hog_features = np.ravel(hog_features)        else:            # get features for specific channel            hog_features = get_hog_features(feature_image[:, :, hog_channel],                                            orient, pix_per_cell, cell_per_block,                                            vis=False, feature_vec=True)        # Apply bin_spatial() to get spatial color features        bin_features = bin_spatial(feature_image)        # Apply color_hist() to get color histogram features        color_hist_features = color_hist(feature_image)        # concatenate all 3 types of features        feature = np.concatenate((bin_features, color_hist_features, hog_features), axis=0)        # Append the new feature vector to the features list        features.append(feature)    # Return list of feature vectors    return featuresdef define_classifier(spatial_size, hist_bins, colorspace, hist_range,                      orient, pix_per_cell, cell_per_block, hog_channel):    imgs_cars = glob.glob("/Users/siddiqui/Downloads/data-set/**/**/*.jpeg")    cars_files = []    not_cars_files = []    for img_file in imgs_cars:        if 'image' in img_file or 'extra' in img_file:            not_cars_files.append(img_file)        else:            cars_files.append(img_file)    # features    car_features = extract_features(cars_files, spatial_size, hist_bins, colorspace, hist_range,                                    orient, pix_per_cell, cell_per_block, hog_channel)    not_cars_features = extract_features(not_cars_files, spatial_size, hist_bins, colorspace, hist_range,                                         orient, pix_per_cell, cell_per_block, hog_channel)    # normalized features    features = np.vstack((car_features, not_cars_features)).astype(np.float64)    features = StandardScaler().fit_transform(features)    # labels    labels = np.hstack((np.ones(len(cars_files)), np.zeros(len(not_cars_files))))    # split dataset    features, labels = shuffle(features, labels)    x_train, x_test, y_train, y_test = train_test_split(features,                                                        labels,                                                        test_size=0.2,                                                        random_state=42)    # initialize SVM with optimized params using GridSearchCV    params = {'kernel': ('linear', 'rbf'), 'C': [1, 10]}    svr = SVC()    clf = GridSearchCV(svr, params)    # train the classifier    t_train_start = time.time()    clf.fit(x_train, y_train)    t_train_end = time.time()    print("best params: {}".format(clf.best_params_))    # prediction using classifier    y_predict = clf.predict(x_test)    score = accuracy_score(y_test, y_predict)    # accuracy check of classifier    print("train time: {:.2f}s".format(t_train_end - t_train_start))    print("score: {:.3f}%".format(score * 100))def run_classifier():    h_bins, spatial = 9, 9    hist_range = (0, 256)    cspace = 'RGB'  # Can be RGB, HSV, LUV, HLS, YUV, YCrCb    orient = 6 # Can be 6, 9, 12    pix_per_cell, cell_per_block = 8, 8    hog_channel = 'ALL'  # Can be 0, 1, 2, or "ALL"    define_classifier(spatial, h_bins, cspace, hist_range,                      orient, pix_per_cell, cell_per_block, hog_channel)